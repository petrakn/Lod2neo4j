"""
Loads LOD files to neo4j.

Parameters to be set in the main function.
The LOD files must be in nt format.
The xxx_lod2neo.n3 file is generated by the script lod_inspect.py. It can be manually edited to set what are properties and what are relations.
Default nro4j database is on localhost.
"""

from urlparse import urlparse
import logging
import os
from rdflib import Namespace, Graph
from rdflib.namespace import RDFS, RDF
from rdflib.term import URIRef
from neo4jconnector import *
import time
from node import *

FORMAT = '[%(asctime)-15s] %(levelname)s: %(message)s'
logging.basicConfig(level=logging.INFO, format=FORMAT)
logger = logging.getLogger(__name__)

def main():
   # #-- reegle
   #  graph_label = "reegle"
   #  file_names = [r"..\data\latest_reegle_dump.nt",
   #                 r"..\data\reegle_lod_links.nt"]
   #  file_name_mapping = r"..\data\latest_reegle_dump.nt_lod2neo.n3 "

    #DBpedia

    #sample DBpedia
    graph_label = "DBpediaSample"
    # file_names = [r"..\data\DBpedia\dbpedia-instance_types_en-sample.nt",
    #              r"..\data\DBpedia\dbpedia-properties-sample.nt"]


    graph_label = "DBpedia"
    file_names = [r"..\data\DBpedia\dbpedia-instance_types_en.nt",
                  r"..\data\DBpedia\dbpedia-mappingbased_properties_cleaned_en.nt"]


    file_names = [r"..\data\DBpedia\instance_types_en.nt",
                  r"..\data\DBpedia\mappingbased_properties_cleaned_en.nt",
                  r"..\data\DBpedia\homepages_en.nt"]

    # add reegle data
    file_names.extend([r"..\data\reegle\reegle-lod2neo.n3",
                      r"..\data\reegle\latest_reegle_dump.nt",
                      r"..\data\reegle\reegle_lod_links.nt"])
                      #r"..\data\reegle\reegle-schema.rdf"]



    file_name_mapping = r"..dbpedia2014-lod2neo.n3"
    ontology_files = [r"..\data\DBpedia\dbpedia_3.9-ontology.n3"]

    ob = Ontology_backbone(ontology_files)

    #g = BaseNeo4jConnector()     # localhost
    g = BaseNeo4jConnector("http://kt-neo4j-dev:7474/db/data/transaction")
    #g = BaseNeo4jConnector("http://simpol.ijs.si:7474//db/data/transaction")

    clean_graph = raw_input('Clean neo4j graph (delete all nodes and relationships? (y/n): ')
    if clean_graph in ['y', 'Y']:
        logger.info("Cleaning neo4j graph")
        # g.query('MATCH (n) OPTIONAL MATCH (n)-[r]-() DELETE r,n;')
        g.query("START r=rel(*) DELETE r")
        g.query("START n=node(*) DELETE n")
        g.commitTx()

    logger.info("Reading the data with RdfLib ...")

    memg = Graph()
    for file_name in file_names:
        logger.debug("Reading file " + file_name)
        name, extension = os.path.splitext(file_name)
        print extension
        memg.parse(file_name, format=extension[1:])
    logger.info("The RDF graph has %s statements." % len(memg))
    logger.info("Reading the RDF mapping file " + file_name_mapping)
    memg.parse(file_name_mapping, format='n3')
    logger.info("The RDF graph has %s statements." % len(memg))

    #-------------------------------------------------------------------------------------------------

    nodes_dict = nodes2neo(g, memg, graph_label, ob)
    relations2neo(g, memg, nodes_dict)


def nodes2neo(g, memg, graph_label, ob=None):
    start_time = time.time()
    ns = Namespace("http://kt.ijs.si/lod2graph#")

    rdf_nodes = set()

    for relation in memg.subjects(RDFS.subPropertyOf, ns["relation"]):
        for (subj, obj) in memg.subject_objects(relation):
            rdf_nodes.add(subj)
            rdf_nodes.add(obj)
    logger.info("Building nodes: %d ", len(rdf_nodes))

    properties = dict()
    for prop in memg.subjects(RDFS.subPropertyOf, ns["property"]):
        properties[prop] = memg.value(subject=prop, predicate=ns["name"], default=uri2short(prop))

    nodes_dict = {}  # uri, neo4j_id
    nodes = []
    statements = []
    i = 0
    for uri in rdf_nodes:
        i += 1
        node = Node(uri)
        if ob:
            ontology_labels = ob.superclasses(memg.value(subject=uri, predicate=RDF.type, default="None"), [])
            node.add_labels(ontology_labels)
        else:
            node.add_label(uri2short(memg.value(subject=uri, predicate=RDF.type, default="None")))
        node.add_labels([graph_label, "LOD"])
        for name_predicate in memg.subjects(RDFS.subPropertyOf, ns["name"]):
            name = memg.value(subject=uri, predicate=name_predicate)
            node.add_name(name)

        for (pred, obj) in memg.predicate_objects(subject=uri):
            if pred in properties:
                node.add_property(properties[pred], obj)

        statements.append(node.to_neo4j_command())
        nodes.append(node)

        if i % 10000 == 0:
            result = g.queryd(statements)
            for j in range(len(nodes)):
                nodes_dict[nodes[j].uri] = result[j]['nid']
            statements = []
            nodes = []
            g.commitTx()
            logger.info('n %s', i)
    if len(statements):
        result = g.queryd(statements)
        for j in range(len(nodes)):
            nodes_dict[nodes[j].uri] = result[j]['nid']
        g.commitTx()
    end_time = time.time()
    time_diff = end_time - start_time
    logger.info("%d nodes inserted in %.3f seconds; %.3f per second.", i, time_diff, i / time_diff)

    return nodes_dict


def relations2neo(g, memg, nodes_dict):
    logger.info('processing relations')
    start_time = time.time()
    ns = Namespace("http://kt.ijs.si/lod2graph#")
    i = 0
    statements = []
    reltypes = set()
    try:
        for relation in memg.subjects(RDFS.subPropertyOf, ns["relation"]):
            rel_name = memg.value(subject=relation, predicate=ns["name"], default=uri2short(relation))
            logger.debug(relation)
            for subj, obj in memg.subject_objects(predicate=relation):
                i += 1
                reltypes.add(rel_name)
                statement = ['start n=node({origin}), m=node({target}) create unique n-[:`%s`]->m' % rel_name,
                             dict(origin=nodes_dict[str(subj)],
                                  target=nodes_dict[str(obj)])]
                statements.append(statement)
                if i % 10000 == 0 and len(statements) >= 0:
                    g.query(statements)
                    statements = []
                    g.commitTx()
                    logger.info('r %d', i)
        if len(statements):
            g.query(statements)
            g.commitTx()
            logger.info('finally %d', len(statements))
    except:
        g.rollbackTx()
        raise
    end_time = time.time()
    time_diff = end_time - start_time
    logger.info("%d relations inserted in %.3f seconds; %.3f per second.", i, time_diff, i/time_diff)


class Ontology_backbone:
    ont = Graph()   # static
    lookup = dict()

    def __init__(self, file_names):

        logger.info("Reading the data with RdfLib ...")

        for file_name in file_names:
            name, extension = os.path.splitext(file_name)
            self.ont.parse(file_name, format=extension[1:])

    def superclasses(self, uri, labels):
        labels.append(uri2short(uri))
        parents = self.ont.objects(subject=URIRef(uri), predicate=RDFS.subClassOf)
        for p in parents:
            if p != URIRef(r"http://www.w3.org/2002/07/owl#Thing"):
                return self.superclasses(p, labels)
        return labels

def uri2short(uri):
    uri_str = ("%s" % uri)
    u = urlparse(uri_str)
    parts = u.netloc.split('.')
    if len(parts) >= 2:
        short = parts[-2]
    else:
        short = u.netloc
    if u.fragment:
        short = short + "_" + u.fragment
    else:
        short = short + "_" + uri[uri.rfind('/') + 1:]
    short = short.replace('.', '_')
    short = short.replace('-', '_')
    return short


if __name__ == "__main__":
    main()

